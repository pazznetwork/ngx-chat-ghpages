<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>@pazznetwork/ngx-chat documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">@pazznetwork/ngx-chat documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content class">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Classes</li>
  <li >QueryOccupantListStanzaBuilder</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/lib/services/adapters/xmpp/plugins/multi-user-chat/multi-user-chat.plugin.ts</code>
        </p>



            <p class="comment">
                <h3>Extends</h3>
            </p>
            <p class="comment">
                        <code><a href="../interfaces/Stanza.html" target="_self" >AbstractStanzaBuilder</a></code>
            </p>



            <section>
    <h3 id="index">Index</h3>
    <table class="table table-sm table-bordered index-table">
        <tbody>

                <tr>
                    <td class="col-md-4">
                        <h6><b>Methods</b></h6>
                    </td>
                </tr>
                <tr>
                    <td class="col-md-4">
                        <ul class="index-list">
                            <li>
                                    <span class="modifier">Static</span>
                                <a href="#build" >build</a>
                            </li>
                            <li>
                                <a href="#toStanza" >toStanza</a>
                            </li>
                        </ul>
                    </td>
                </tr>





        </tbody>
    </table>
</section>

            <section>
    <h3 id="constructor">Constructor</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
<code>constructor(roomJid: JID)</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="120" class="link-to-prism">src/lib/services/adapters/xmpp/plugins/multi-user-chat/multi-user-chat.plugin.ts:120</a></div>
                            </td>
                        </tr>

                <tr>
                    <td class="col-md-4">
                            <div>
                                    <b>Parameters :</b>
                                    <table class="params">
                                        <thead>
                                            <tr>
                                                <td>Name</td>
                                                    <td>Type</td>
                                                <td>Optional</td>
                                            </tr>
                                        </thead>
                                        <tbody>
                                                <tr>
                                                        <td>roomJid</td>
                                                  
                                                        <td>
                                                                    <code>JID</code>
                                                        </td>
                                                  
                                                    <td>
                                                            No
                                                    </td>
                                                    
                                                </tr>
                                        </tbody>
                                    </table>
                            </div>
                    </td>
                </tr>
            </tbody>
        </table>
</section>


            <section>
    
    <h3 id="methods">
        Methods
    </h3>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="build"></a>
                    <span class="name">
                        <span class="modifier">Static</span>
                        <span ><b>build</b></span>
                        <a href="#build"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                    <span class="modifier-icon icon ion-ios-reset"></span>
                    <code>build(roomJid: JID)</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Defined in <a href="" data-line="126"
                            class="link-to-prism">src/lib/services/adapters/xmpp/plugins/multi-user-chat/multi-user-chat.plugin.ts:126</a></div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">

                    <div class="io-description">
                        <b>Parameters :</b>
                        
                        <table class="params">
                            <thead>
                                <tr>
                                    <td>Name</td>
                                    <td>Type</td>
                                    <td>Optional</td>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>roomJid</td>
                                    <td>
                                            <code>JID</code>
                                    </td>

                                    <td>
                                        No
                                    </td>


                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div>
                    </div>
                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="../interfaces/Stanza.html" target="_self" >Stanza</a></code>

                    </div>
                    <div class="io-description">
                        
                    </div>
                </td>
            </tr>
        </tbody>
    </table>
    <table class="table table-sm table-bordered">
        <tbody>
            <tr>
                <td class="col-md-4">
                    <a name="toStanza"></a>
                    <span class="name">
                        <span ><b>toStanza</b></span>
                        <a href="#toStanza"><span class="icon ion-ios-link"></span></a>
                    </span>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
<code>toStanza()</code>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">
                    <div class="io-line">Inherited from         <code><a href="../interfaces/Stanza.html" target="_self" >AbstractStanzaBuilder</a></code>
</div>
                </td>
            </tr>
            <tr>
                <td class="col-md-4">
                        <div class="io-line">Defined in         <code><a href="../interfaces/Stanza.html#source" target="_self" >AbstractStanzaBuilder:130</a></code>
</div>
                </td>
            </tr>


            <tr>
                <td class="col-md-4">

                    <div class="io-description">
                        <b>Returns : </b>        <code><a href="../interfaces/Stanza.html" target="_self" >Stanza</a></code>

                    </div>
                </td>
            </tr>
        </tbody>
    </table>
</section>





    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { jid as parseJid, xml } from &#x27;@xmpp/client&#x27;;
import { JID } from &#x27;@xmpp/jid&#x27;;
import { Element } from &#x27;ltx&#x27;;
import { BehaviorSubject, Subject } from &#x27;rxjs&#x27;;
import { Direction } from &#x27;../../../../../core/message&#x27;;
import { IqResponseStanza, Stanza } from &#x27;../../../../../core/stanza&#x27;;
import { LogService } from &#x27;../../../../log.service&#x27;;
import { AbstractStanzaBuilder } from &#x27;../../abstract-stanza-builder&#x27;;
import { StanzaBuilder } from &#x27;../../stanza-builder&#x27;;
import { XmppChatAdapter } from &#x27;../../xmpp-chat-adapter.service&#x27;;
import { AbstractXmppPlugin } from &#x27;../abstract-xmpp-plugin&#x27;;
import { MessageReceivedEvent } from &#x27;../message.plugin&#x27;;
import { ServiceDiscoveryPlugin } from &#x27;../service-discovery.plugin&#x27;;
import { Presence } from &#x27;../../../../../core/presence&#x27;;
import { Room } from &#x27;./room&#x27;;
import { Affiliation, AffiliationModification } from &#x27;./affiliation&#x27;;
import { Role, RoleModification } from &#x27;./role&#x27;;
import { RoomUser } from &#x27;./room-user&#x27;;
import { RoomOccupant } from &#x27;./room-occupant&#x27;;
import { Invitation } from &#x27;./invitation&#x27;;
import { RoomMessage } from &#x27;./room-message&#x27;;
import {
    Form,
    FORM_NS,
    getField,
    parseForm,
    serializeToSubmitForm,
    setFieldValue,
    TextualFormField,
} from &#x27;../../../../../core/form&#x27;;
import { XmppResponseError } from &#x27;../../xmpp-response.error&#x27;;
import { mucNs, mucAdminNs, mucOwnerNs, mucRoomConfigFormNs, mucUserNs } from &#x27;./multi-user-chat-constants&#x27;;

/**
 * see:
 * https://xmpp.org/extensions/xep-0045.html#terms-rooms
 */
export interface RoomCreationOptions extends RoomConfiguration {
    /**
     * The room id to create the room with. This is the &#x60;local&#x60; part of the room JID.
     */
    roomId: string;
    /**
     * Optional nickname to use in the room. Current user&#x27;s nickname will be used if not provided.
     */
    nick?: string;
}

export interface RoomConfiguration {
    /**
     * Optional name for the room. If none is provided, room will be only identified by its JID.
     */
    name?: string;
    /**
     * A room that can be found by any user through normal means such as searching and service discovery
     */
    public?: boolean;
    /**
     * for true:
     * A room that a user cannot enter without being on the member list.
     * for false:
     * A room that non-banned entities are allowed to enter without being on the member list.
     */
    membersOnly?: boolean;
    /**
     * for true:
     * A room in which an occupant&#x27;s full JID is exposed to all other occupants,
     * although the occupant can request any desired room nickname.
     * for false:
     * A room in which an occupant&#x27;s full JID can be discovered by room moderators only.
     */
    nonAnonymous?: boolean;
    /**
     * for true:
     * A room that is not destroyed if the last occupant exits.
     * for false:
     * A room that is destroyed if the last occupant exits.
     */
    persistentRoom?: boolean;
    /**
     * allow ejabberd MucSub subscriptions.
     * Room occupants are allowed to subscribe to message notifications being archived while they were offline
     */
    allowSubscription?: boolean;

    /**
    * Only occupants with &quot;voice&quot; can send public messages. The default value is true.
    */
    moderated?: boolean;
}

export interface RoomMetadata {
    [key: string]: any;
}

class QueryAffiliatedMemberListStanzaBuilder extends AbstractStanzaBuilder {

    constructor(
        private readonly roomJid: JID,
        private readonly queryType: &#x27;affiliation&#x27; | &#x27;role&#x27;,
        private readonly affiliationOrRole: Affiliation | Role,
    ) {
        super();
    }

    static build(roomJid: JID, ...[queryType, affiliationOrRole]:
        [queryType: &#x27;affiliation&#x27;, affiliation: Affiliation] | [queryType: &#x27;role&#x27;, role: Role]): Stanza {
        return new QueryAffiliatedMemberListStanzaBuilder(roomJid, queryType, affiliationOrRole).toStanza();
    }

    toStanza(): Stanza {
        return xml(&#x27;iq&#x27;, {type: &#x27;get&#x27;, to: this.roomJid.toString()},
            xml(&#x27;query&#x27;, {xmlns: mucAdminNs},
                xml(&#x27;item&#x27;, {[this.queryType]: this.affiliationOrRole}),
            ),
        ) as Stanza;
    }
}

class QueryOccupantListStanzaBuilder extends AbstractStanzaBuilder {

    constructor(private readonly roomJid: JID) {
        super();
    }

    static build(roomJid: JID): Stanza {
        return new QueryOccupantListStanzaBuilder(roomJid).toStanza();
    }

    toStanza(): Stanza {
        return xml(&#x27;iq&#x27;, {type: &#x27;get&#x27;, to: this.roomJid.toString()},
            xml(&#x27;query&#x27;, {xmlns: ServiceDiscoveryPlugin.DISCO_ITEMS}),
        ) as Stanza;
    }
}

export interface RoomSummary {
    jid: JID;
    name: string;
    roomInfo: Form | null;
}

class ModifyAffiliationsOrRolesStanzaBuilder extends AbstractStanzaBuilder {

    constructor(
        private readonly roomJid: JID,
        private readonly modifications: readonly (AffiliationModification | RoleModification)[],
    ) {
        super();
    }

    static build(
        roomJid: JID,
        modifications: readonly (AffiliationModification | RoleModification)[],
    ): Stanza {
        return new ModifyAffiliationsOrRolesStanzaBuilder(roomJid, modifications).toStanza();
    }

    toStanza(): Stanza {
        return xml(&#x27;iq&#x27;, {to: this.roomJid.toString(), type: &#x27;set&#x27;},
            xml(
                &#x27;query&#x27;,
                {xmlns: mucAdminNs},
                ...this.modifications.map(modification &#x3D;&gt; this.buildItem(modification)),
            ),
        ) as Stanza;
    }

    private buildItem(modification: AffiliationModification | RoleModification): Element {
        const {reason, ...attrs} &#x3D; modification;
        return xml(
            &#x27;item&#x27;,
            &#x27;userJid&#x27; in attrs
                ? {
                    jid: attrs.userJid.toString(),
                    affiliation: attrs.affiliation,
                }
                : {
                    nick: attrs.nick,
                    role: attrs.role,
                },
            reason ? xml(&#x27;reason&#x27;, {}, reason) : null,
        );
    }
}

/**
 * The MultiUserChatPlugin tries to provide the necessary functionality for a multi-user text chat,
 * whereby multiple XMPP users can exchange messages in the context of a room or channel, similar to Internet Relay Chat (IRC).
 * For more details see:
 * @see https://xmpp.org/extensions/xep-0045.html
 */
export class MultiUserChatPlugin extends AbstractXmppPlugin {
    readonly rooms$ &#x3D; new BehaviorSubject&lt;Room[]&gt;([]);
    readonly message$ &#x3D; new Subject&lt;Room&gt;();

    private onInvitationSubject &#x3D; new Subject&lt;Invitation&gt;();
    readonly onInvitation$ &#x3D; this.onInvitationSubject.asObservable();

    constructor(
        private readonly xmppChatAdapter: XmppChatAdapter,
        private readonly logService: LogService,
        private readonly serviceDiscoveryPlugin: ServiceDiscoveryPlugin,
    ) {
        super();
    }

    onOffline(): void {
        this.rooms$.next([]);
    }

    handleStanza(stanza: Stanza, archiveDelayElement?: Stanza): boolean {
        if (this.isRoomPresenceStanza(stanza)) {
            return this.handleRoomPresenceStanza(stanza);
        } else if (this.isRoomMessageStanza(stanza)) {
            return this.handleRoomMessageStanza(stanza, archiveDelayElement);
        } else if (this.isRoomSubjectStanza(stanza)) {
            return this.handleRoomSubjectStanza(stanza, archiveDelayElement);
        } else if (this.isRoomInvitationStanza(stanza)) {
            return this.handleRoomInvitationStanza(stanza);
        }
        return false;
    }

    /**
     * Resolves if room could be configured as requested, rejects if room did exist or server did not accept configuration.
     */
    async createRoom(options: RoomCreationOptions): Promise&lt;Room&gt; {
        const {roomId, nick} &#x3D; options;
        const service &#x3D; await this.serviceDiscoveryPlugin.findService(&#x27;conference&#x27;, &#x27;text&#x27;);
        const occupantJid &#x3D; parseJid(roomId, service.jid, nick);
        const {presenceResponse, room} &#x3D; await this.joinRoomInternal(occupantJid);

        const itemElement &#x3D; presenceResponse.getChild(&#x27;x&#x27;).getChild(&#x27;item&#x27;);
        if (itemElement.attrs.affiliation !&#x3D;&#x3D; Affiliation.owner) {
            throw new Error(&#x27;error creating room, user is not owner: &#x27; + presenceResponse.toString());
        }

        try {
            await this.applyRoomConfiguration(room.roomJid, options);
            room.name &#x3D; options.name || undefined;
            this.rooms$.next(this.rooms$.getValue());
        } catch (e) {
            this.logService.error(&#x27;room configuration rejected&#x27;, e);
            throw e;
        }

        return room;
    }

    async destroyRoom(roomJid: JID): Promise&lt;IqResponseStanza&lt;&#x27;result&#x27;&gt;&gt; {
        let roomDestroyedResponse: IqResponseStanza&lt;&#x27;result&#x27;&gt;;
        try {
            roomDestroyedResponse &#x3D; await this.xmppChatAdapter.chatConnectionService.sendIq(
                xml(&#x27;iq&#x27;, {type: &#x27;set&#x27;, to: roomJid.toString()},
                    xml(&#x27;query&#x27;, {xmlns: mucOwnerNs},
                        xml(&#x27;destroy&#x27;))));
        } catch (e) {
            this.logService.error(&#x27;error destroying room&#x27;);
            throw e;
        }

        // TODO: refactor so that we instead listen to the presence destroy stanza
        const allRoomsWithoutDestroyedRoom &#x3D; this.rooms$.getValue().filter(
            room &#x3D;&gt; !room.roomJid.equals(roomJid),
        );

        this.rooms$.next(allRoomsWithoutDestroyedRoom);

        return roomDestroyedResponse;
    }

    async joinRoom(occupantJid: JID): Promise&lt;Room&gt; {
        const {room} &#x3D; await this.joinRoomInternal(occupantJid);
        this.rooms$.next(this.rooms$.getValue());
        return room;
    }

    async getRoomInfo(roomJid: JID): Promise&lt;Form | null&gt; {
        const roomInfoResponse &#x3D; await this.xmppChatAdapter.chatConnectionService.sendIq(
            xml(&#x27;iq&#x27;, {type: &#x27;get&#x27;, to: roomJid.toString()},
                xml(&#x27;query&#x27;, {xmlns: ServiceDiscoveryPlugin.DISCO_INFO}),
            ),
        );
        const formEl &#x3D; roomInfoResponse
            .getChild(&#x27;query&#x27;, ServiceDiscoveryPlugin.DISCO_INFO)
            ?.getChild(&#x27;x&#x27;, FORM_NS);

        if (formEl) {
            return parseForm(formEl);
        }

        return null;
    }

    async queryAllRooms(): Promise&lt;RoomSummary[]&gt; {
        const conferenceServer &#x3D; await this.serviceDiscoveryPlugin.findService(&#x27;conference&#x27;, &#x27;text&#x27;);
        const to &#x3D; conferenceServer.jid.toString();

        const result: RoomSummary[] &#x3D; [];

        let roomQueryResponse &#x3D; await this.xmppChatAdapter.chatConnectionService.sendIq(
            xml(&#x27;iq&#x27;, {type: &#x27;get&#x27;, to},
                xml(&#x27;query&#x27;, {xmlns: ServiceDiscoveryPlugin.DISCO_ITEMS}),
            ),
        );
        result.push(...this.extractRoomSummariesFromResponse(roomQueryResponse));

        let resultSet &#x3D; this.extractResultSetFromResponse(roomQueryResponse);
        while (resultSet &amp;&amp; resultSet.getChild(&#x27;last&#x27;)) {
            const lastReceivedRoom &#x3D; resultSet.getChildText(&#x27;last&#x27;);
            roomQueryResponse &#x3D; await this.xmppChatAdapter.chatConnectionService.sendIq(
                xml(&#x27;iq&#x27;, {type: &#x27;get&#x27;, to},
                    xml(&#x27;query&#x27;, {xmlns: ServiceDiscoveryPlugin.DISCO_ITEMS},
                        xml(&#x27;set&#x27;, {xmlns: &#x27;http://jabber.org/protocol/rsm&#x27;},
                            xml(&#x27;max&#x27;, {}, &#x27;250&#x27;),
                            xml(&#x27;after&#x27;, {}, lastReceivedRoom),
                        ),
                    ),
                ),
            );
            result.push(...this.extractRoomSummariesFromResponse(roomQueryResponse));
            resultSet &#x3D; this.extractResultSetFromResponse(roomQueryResponse);
        }

        await Promise.all(
            result.map(async (summary) &#x3D;&gt; {
                summary.roomInfo &#x3D; await this.getRoomInfo(summary.jid);
            }),
        );

        return result;
    }

    /**
     * Get all members of a MUC-Room with their affiliation to the room using the rooms fullJid
     * @param roomJid jid of the room
     */
    async queryUserList(roomJid: JID): Promise&lt;RoomUser[]&gt; {
        const memberQueryResponses &#x3D; await Promise.all(
            [
                ...Object
                    .values(Affiliation)
                    .map(affiliation &#x3D;&gt;
                        this.xmppChatAdapter.chatConnectionService.sendIq(
                            QueryAffiliatedMemberListStanzaBuilder.build(roomJid, &#x27;affiliation&#x27;, affiliation),
                        ),
                    ),
                ...Object
                    .values(Role)
                    .map(role &#x3D;&gt;
                        this.xmppChatAdapter.chatConnectionService.sendIq(
                            QueryAffiliatedMemberListStanzaBuilder.build(roomJid, &#x27;role&#x27;, role),
                        ),
                    ),
            ],
        );
        const members &#x3D; new Map&lt;string, RoomUser&gt;();
        for (const memberQueryResponse of memberQueryResponses) {
            memberQueryResponse
                .getChild(&#x27;query&#x27;, mucAdminNs)
                .getChildren(&#x27;item&#x27;)
                .forEach((memberItem: Element) &#x3D;&gt; {
                    const userJid &#x3D; parseJid(memberItem.attrs.jid);
                    const roomUser &#x3D; members.get(userJid.bare().toString()) || {
                        userIdentifiers: [],
                        affiliation: Affiliation.none,
                        role: Role.none,
                    } as RoomUser;
                    roomUser.userIdentifiers.push({
                        userJid,
                        nick: memberItem.attrs.nick &amp;&amp; memberItem.attrs.nick,
                    });
                    // tslint:disable no-unused-expression
                    memberItem.attrs.affiliation &amp;&amp; (roomUser.affiliation &#x3D; memberItem.attrs.affiliation);
                    memberItem.attrs.role &amp;&amp; (roomUser.role &#x3D; memberItem.attrs.role);
                    // tslint:enable no-unused-expression
                    members.set(userJid.bare().toString(), roomUser);
                });
        }

        return [...members.values()];
    }

    async modifyAffiliationOrRole(roomJid: JID, modification: AffiliationModification | RoleModification): Promise&lt;IqResponseStanza&gt; {
        return await this.xmppChatAdapter.chatConnectionService.sendIq(
            ModifyAffiliationsOrRolesStanzaBuilder.build(roomJid, [modification]),
        );
    }

    async sendMessage(room: Room, body: string, thread?: string): Promise&lt;void&gt; {
        const from &#x3D; this.xmppChatAdapter.chatConnectionService.userJid.toString();
        const roomJid &#x3D; room.roomJid.toString();
        const roomMessageStanza &#x3D;
            thread
                ? StanzaBuilder.buildRoomMessageWithThread(from, roomJid, body, thread)
                : StanzaBuilder.buildRoomMessageWithBody(from, roomJid, body);

        for (const plugin of this.xmppChatAdapter.plugins) {
            plugin.beforeSendMessage(roomMessageStanza);
        }

        return await this.xmppChatAdapter.chatConnectionService.send(roomMessageStanza);
    }

    /**
     * requests a configuration form for a room which returns with the default values
     * for an example see:
     * https://xmpp.org/extensions/xep-0045.html#registrar-formtype-owner
     */
    async getRoomConfiguration(roomJid: JID): Promise&lt;Form&gt; {
        const configurationForm &#x3D; await this.xmppChatAdapter.chatConnectionService.sendIq(
            xml(&#x27;iq&#x27;, {type: &#x27;get&#x27;, to: roomJid.toString()},
                xml(&#x27;query&#x27;, {xmlns: mucOwnerNs}),
            ),
        );

        const formElement &#x3D; configurationForm.getChild(&#x27;query&#x27;).getChild(&#x27;x&#x27;, FORM_NS);
        if (!formElement) {
            throw new Error(&#x27;room not configurable&#x27;);
        }

        return parseForm(formElement);
    }

    async applyRoomConfiguration(roomJid: JID, roomConfiguration: RoomConfiguration): Promise&lt;void&gt; {
        const roomConfigForm &#x3D; await this.getRoomConfiguration(roomJid);

        const formTypeField &#x3D; getField(roomConfigForm, &#x27;FORM_TYPE&#x27;) as TextualFormField | undefined;
        if (formTypeField.value !&#x3D;&#x3D; mucRoomConfigFormNs) {
            throw new Error(&#x60;unexpected form type for room configuration form: formType&#x3D;${formTypeField.value}, formTypeField&#x3D;${JSON.stringify(formTypeField)}&#x60;);
        }

        if (typeof roomConfiguration.name &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
            setFieldValue(roomConfigForm, &#x27;text-single&#x27;, &#x27;muc#roomconfig_roomname&#x27;, roomConfiguration.name);
        }
        if (typeof roomConfiguration.nonAnonymous &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
            setFieldValue(
                roomConfigForm,
                &#x27;list-single&#x27;,
                &#x27;muc#roomconfig_whois&#x27;,
                roomConfiguration.nonAnonymous ? &#x27;anyone&#x27; : &#x27;moderators&#x27;,
            );
        }
        if (typeof roomConfiguration.public &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
            setFieldValue(roomConfigForm, &#x27;boolean&#x27;, &#x27;muc#roomconfig_publicroom&#x27;, roomConfiguration.public);
        }
        if (typeof roomConfiguration.membersOnly &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
            setFieldValue(roomConfigForm, &#x27;boolean&#x27;, &#x27;muc#roomconfig_membersonly&#x27;, roomConfiguration.membersOnly);
        }
        if (typeof roomConfiguration.persistentRoom &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
            setFieldValue(roomConfigForm, &#x27;boolean&#x27;, &#x27;muc#roomconfig_persistentroom&#x27;, roomConfiguration.persistentRoom);
        }
        if (typeof roomConfiguration.allowSubscription &#x3D;&#x3D;&#x3D; &#x27;boolean&#x27;) {
            setFieldValue(roomConfigForm, &#x27;boolean&#x27;, &#x27;allow_subscription&#x27;, roomConfiguration.allowSubscription);
        }

        await this.xmppChatAdapter.chatConnectionService.sendIq(
            xml(&#x27;iq&#x27;, {type: &#x27;set&#x27;, to: roomJid.toString()},
                xml(&#x27;query&#x27;, {xmlns: mucOwnerNs},
                    serializeToSubmitForm(roomConfigForm),
                ),
            ),
        );
    }

    getRoomByJid(jid: JID): Room | undefined {
        return this.rooms$.getValue().find(room &#x3D;&gt; room.roomJid.equals(jid.bare()));
    }

    async banUser(occupantJid: JID, roomJid: JID, reason?: string): Promise&lt;IqResponseStanza&gt; {
        const userJid &#x3D; await this.getUserJidByOccupantJid(occupantJid, roomJid);

        const response &#x3D; await this.modifyAffiliationOrRole(roomJid, {
            userJid: userJid.bare(),
            affiliation: Affiliation.outcast,
            reason,
        });
        this.logService.debug(&#x60;ban response ${response.toString()}&#x60;);

        return response;
    }

    async unbanUser(occupantJid: JID, roomJid: JID): Promise&lt;IqResponseStanza&gt; {
        const userJid &#x3D; await this.getUserJidByOccupantJid(occupantJid, roomJid);

        const banList &#x3D; (await this.getBanList(roomJid)).map(bannedUser &#x3D;&gt; bannedUser.userJid);
        this.logService.debug(&#x60;ban list: ${JSON.stringify(banList)}&#x60;);

        if (!banList.find(bannedJid &#x3D;&gt; bannedJid.equals(userJid))) {
            throw new Error(&#x60;error unbanning: ${userJid} isn&#x27;t on the ban list&#x60;);
        }

        const response &#x3D; await this.modifyAffiliationOrRole(roomJid, {userJid, affiliation: Affiliation.none});
        this.logService.debug(&#x27;unban response: &#x27; + response.toString());

        return response;
    }

    async getBanList(roomJid: JID): Promise&lt;AffiliationModification[]&gt; {
        const iq &#x3D; xml(&#x27;iq&#x27;, {to: roomJid.toString(), type: &#x27;get&#x27;},
            xml(&#x27;query&#x27;, {xmlns: mucAdminNs},
                xml(&#x27;item&#x27;, {affiliation: Affiliation.outcast}),
            ),
        );
        const response &#x3D; await this.xmppChatAdapter.chatConnectionService.sendIq(iq);

        return response.getChild(&#x27;query&#x27;).getChildren(&#x27;item&#x27;).map(item &#x3D;&gt; ({
            userJid: parseJid(item.attrs.jid),
            affiliation: item.attrs.affiliation,
            reason: item.getChild(&#x27;reason&#x27;)?.getText(),
        }));
    }

    async inviteUser(inviteeJid: JID, roomJid: JID, invitationMessage?: string): Promise&lt;void&gt; {
        const from &#x3D; this.xmppChatAdapter.chatConnectionService.userJid.toString();
        const stanza &#x3D; xml(&#x27;message&#x27;, {to: roomJid.toString(), from},
            xml(&#x27;x&#x27;, {xmlns: mucUserNs},
                xml(&#x27;invite&#x27;, {to: inviteeJid.toString()},
                    invitationMessage ? xml(&#x27;reason&#x27;, {}, invitationMessage) : null,
                ),
            ),
        );
        await this.xmppChatAdapter.chatConnectionService.send(stanza);
    }

    async declineRoomInvite(occupantJid: JID, reason?: string) {
        const to &#x3D; occupantJid.bare().toString();
        const from &#x3D; this.xmppChatAdapter.chatConnectionService.userJid.toString();
        const stanza &#x3D; xml(&#x27;message&#x27;, {to, from},
            xml(&#x27;x&#x27;, {xmlns: mucUserNs},
                xml(&#x27;decline&#x27;, {to},
                    reason ? xml(&#x27;reason&#x27;, {}, reason) : null
                ),
            ),
        );
        await this.xmppChatAdapter.chatConnectionService.send(stanza);
    }

    async kickOccupant(nick: string, roomJid: JID, reason?: string): Promise&lt;IqResponseStanza&gt; {
        const response &#x3D; await this.modifyAffiliationOrRole(roomJid, {nick, role: Role.none, reason});
        this.logService.debug(&#x60;kick occupant response: ${response.toString()}&#x60;);
        return response;
    }

    async changeUserNickname(newNick: string, roomJid: JID): Promise&lt;void&gt; {
        const newRoomJid &#x3D; parseJid(roomJid.toString());
        newRoomJid.resource &#x3D; newNick;
        const stanza &#x3D; xml(&#x27;presence&#x27;, {
            to: newRoomJid.toString(),
            from: this.xmppChatAdapter.chatConnectionService.userJid.toString(),
        });
        await this.xmppChatAdapter.chatConnectionService.send(stanza);
    }

    async leaveRoom(occupantJid: JID, status?: string): Promise&lt;void&gt; {
        const stanza &#x3D; xml(&#x27;presence&#x27;, {
                to: occupantJid.toString(),
                from: this.xmppChatAdapter.chatConnectionService.userJid.toString(),
                type: Presence[Presence.unavailable],
            },
            status ? xml(&#x27;status&#x27;, {}, status) : null,
        );

        await this.xmppChatAdapter.chatConnectionService.send(stanza);
        this.logService.debug(&#x60;occupant left room: occupantJid&#x3D;${occupantJid.toString()}&#x60;);
    }

    async changeRoomSubject(roomJid: JID, subject: string): Promise&lt;void&gt; {
        const from &#x3D; this.xmppChatAdapter.chatConnectionService.userJid.toString();
        await this.xmppChatAdapter.chatConnectionService.send(
            xml(&#x27;message&#x27;, {to: roomJid.toString(), from, type: &#x27;groupchat&#x27;},
                xml(&#x27;subject&#x27;, {}, subject),
            ),
        );
        this.logService.debug(&#x60;room subject changed: roomJid&#x3D;${roomJid.toString()}, new subject&#x3D;${subject}&#x60;);
    }

    isRoomInvitationStanza(stanza: Stanza): boolean {
        let x: Element | undefined;
        return stanza.name &#x3D;&#x3D;&#x3D; &#x27;message&#x27;
            &amp;&amp; (x &#x3D; stanza.getChild(&#x27;x&#x27;, mucUserNs)) !&#x3D; null
            &amp;&amp; (x.getChild(&#x27;invite&#x27;) !&#x3D; null || x.getChild(&#x27;decline&#x27;) !&#x3D; null);
    }

    async grantMembership(userJid: JID, roomJid: JID, reason?: string) {
        await this.setAffiliation(userJid, roomJid, Affiliation.member, reason);
    }

    async revokeMembership(userJid: JID, roomJid: JID, reason?: string) {
        await this.setAffiliation(userJid, roomJid, Affiliation.none, reason);
    }

    async grantAdmin(userJid: JID, roomJid: JID, reason?: string) {
        await this.setAffiliation(userJid, roomJid, Affiliation.admin, reason);
    }

    async revokeAdmin(userJid: JID, roomJid: JID, reason?: string) {
        await this.setAffiliation(userJid, roomJid, Affiliation.member, reason);
    }

    async grantModeratorStatus(occupantNick: string, roomJid: JID, reason?: string) {
        await this.setRole(occupantNick, roomJid, Role.moderator, reason);
    }

    async revokeModeratorStatus(occupantNick: string, roomJid: JID, reason?: string) {
        await this.setRole(occupantNick, roomJid, Role.participant, reason);
    }

    private isRoomPresenceStanza(stanza: Stanza): boolean {
        return stanza.name &#x3D;&#x3D;&#x3D; &#x27;presence&#x27; &amp;&amp; (
            stanza.getChild(&#x27;x&#x27;, mucNs)
            || stanza.getChild(&#x27;x&#x27;, mucUserNs)
        ) !&#x3D; null;
    }

    private handleRoomPresenceStanza(stanza: Stanza): boolean {
        const stanzaType &#x3D; stanza.attrs.type;

        if (stanzaType &#x3D;&#x3D;&#x3D; &#x27;error&#x27;) {
            this.logService.error(stanza);
            throw new Error(&#x27;error handling message, stanza: &#x27; + stanza);
        }

        const occupantJid &#x3D; parseJid(stanza.attrs.from);
        const roomJid &#x3D; occupantJid.bare();

        const xEl &#x3D; stanza.getChild(&#x27;x&#x27;, mucUserNs);

        const itemEl &#x3D; xEl.getChild(&#x27;item&#x27;);
        const subjectOccupant: RoomOccupant &#x3D; {
            occupantJid,
            affiliation: itemEl.attrs.affiliation,
            role: itemEl.attrs.role,
            nick: occupantJid.resource,
        };

        const room &#x3D; this.getOrCreateRoom(occupantJid);
        const statusCodes: string[] &#x3D; xEl.getChildren(&#x27;status&#x27;).map(status &#x3D;&gt; status.attrs.code);
        const isCurrenUser &#x3D; statusCodes.includes(&#x27;110&#x27;);
        if (stanzaType &#x3D;&#x3D;&#x3D; &#x27;unavailable&#x27;) {
            const actor &#x3D; itemEl.getChild(&#x27;actor&#x27;)?.attrs.nick;
            const reason &#x3D; itemEl.getChild(&#x27;reason&#x27;)?.getText();

            if (statusCodes.includes(&#x27;333&#x27;)) {
                if (isCurrenUser) {
                    this.rooms$.next(this.rooms$.getValue().filter(r &#x3D;&gt; !r.jidBare.equals(roomJid)));
                }
                return room.handleOccupantConnectionError(subjectOccupant, isCurrenUser);
            } else if (statusCodes.includes(&#x27;307&#x27;)) {
                if (isCurrenUser) {
                    this.rooms$.next(this.rooms$.getValue().filter(r &#x3D;&gt; !r.jidBare.equals(roomJid)));
                }
                return room.handleOccupantKicked(subjectOccupant, isCurrenUser, actor, reason);
            } else if (statusCodes.includes(&#x27;301&#x27;)) {
                if (isCurrenUser) {
                    this.rooms$.next(this.rooms$.getValue().filter(r &#x3D;&gt; !r.jidBare.equals(roomJid)));
                }
                return room.handleOccupantBanned(subjectOccupant, isCurrenUser, actor, reason);
            } else if (statusCodes.includes(&#x27;303&#x27;)) {
                const handled &#x3D; room.handleOccupantChangedNick(subjectOccupant, isCurrenUser, xEl.getChild(&#x27;item&#x27;).attrs.nick);
                if (handled &amp;&amp; isCurrenUser) {
                    this.rooms$.next(this.rooms$.getValue());
                }
                return handled;
            } else if (statusCodes.includes(&#x27;321&#x27;)) {
                if (isCurrenUser) {
                    this.rooms$.next(this.rooms$.getValue().filter(r &#x3D;&gt; !r.jidBare.equals(roomJid)));
                }
                return room.handleOccupantLostMembership(subjectOccupant, isCurrenUser);
            } else {
                if (isCurrenUser) {
                    this.rooms$.next(this.rooms$.getValue().filter(r &#x3D;&gt; !r.jidBare.equals(roomJid)));
                }
                return room.handleOccupantLeft(subjectOccupant, isCurrenUser);
            }
        } else if (!stanzaType) {
            if (room.hasOccupant(subjectOccupant.occupantJid)) {
                const oldOccupant &#x3D; room.getOccupant(subjectOccupant.occupantJid);
                return room.handleOccupantModified(subjectOccupant, oldOccupant, isCurrenUser);
            } else {
                return room.handleOccupantJoined(subjectOccupant, isCurrenUser);
            }
        }

        return false;
    }

    private getOrCreateRoom(roomJid: JID): Room {
        roomJid &#x3D; roomJid.bare();
        let room &#x3D; this.getRoomByJid(roomJid);
        if (!room) {
            room &#x3D; new Room(roomJid, this.logService);
            this.rooms$.next([room, ...this.rooms$.getValue()]);
        }
        return room;
    }

    private async joinRoomInternal(roomJid: JID): Promise&lt;{ presenceResponse: Stanza, room: Room }&gt; {
        if (this.getRoomByJid(roomJid.bare())) {
            throw new Error(&#x27;can not join room more than once: &#x27; + roomJid.bare().toString());
        }
        const userJid &#x3D; this.xmppChatAdapter.chatConnectionService.userJid;
        const occupantJid &#x3D; parseJid(roomJid.local, roomJid.domain, roomJid.resource || userJid.local);

        let roomInfo: Form | null &#x3D; null;
        try {
            roomInfo &#x3D; await this.getRoomInfo(occupantJid.bare());
        } catch (e) {
            if (!(e instanceof XmppResponseError) || e.errorCondition !&#x3D;&#x3D; &#x27;item-not-found&#x27;) {
                throw e;
            }
        }

        try {
            const presenceResponse &#x3D; await this.xmppChatAdapter.chatConnectionService.sendAwaitingResponse(
                xml(&#x27;presence&#x27;, {to: occupantJid.toString()},
                    xml(&#x27;x&#x27;, {xmlns: mucNs}),
                ),
            );
            this.handleRoomPresenceStanza(presenceResponse);

            const room &#x3D; this.getOrCreateRoom(occupantJid.bare());
            room.nick &#x3D; occupantJid.resource;
            if (roomInfo) {
                room.name &#x3D; getField(roomInfo, &#x27;muc#roomconfig_roomname&#x27;)?.value as string | undefined;
                room.description &#x3D; getField(roomInfo, &#x27;muc#roominfo_description&#x27;)?.value as string | undefined || &#x27;&#x27;;
            }

            return {presenceResponse, room};
        } catch (e) {
            this.logService.error(&#x27;error joining room&#x27;, e);
            throw e;
        }
    }

    private extractRoomSummariesFromResponse(iq: IqResponseStanza): RoomSummary[] {
        return iq
            .getChild(&#x27;query&#x27;, ServiceDiscoveryPlugin.DISCO_ITEMS)
            ?.getChildren(&#x27;item&#x27;)
            ?.reduce&lt;RoomSummary[]&gt;((acc, item) &#x3D;&gt; {
                const {jid, name} &#x3D; item.attrs;

                if (typeof jid &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;&amp; typeof name &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
                    acc.push({
                        jid: parseJid(jid),
                        name,
                        roomInfo: null,
                    });
                }

                return acc;
            }, []) || [];
    }

    private extractResultSetFromResponse(iq: IqResponseStanza): Stanza {
        return iq
            .getChild(&#x27;query&#x27;, ServiceDiscoveryPlugin.DISCO_ITEMS)
            ?.getChild(&#x27;set&#x27;, &#x27;http://jabber.org/protocol/rsm&#x27;) as Stanza;
    }

    private isRoomMessageStanza(stanza: Stanza): boolean {
        return stanza.name &#x3D;&#x3D;&#x3D; &#x27;message&#x27; &amp;&amp; stanza.attrs.type &#x3D;&#x3D;&#x3D; &#x27;groupchat&#x27; &amp;&amp; !!stanza.getChildText(&#x27;body&#x27;)?.trim();
    }

    private handleRoomMessageStanza(messageStanza: Stanza, archiveDelayElement?: Stanza): boolean {
        const delayElement &#x3D; archiveDelayElement ?? messageStanza.getChild(&#x27;delay&#x27;);
        const datetime &#x3D; delayElement?.attrs.stamp
            ? new Date(delayElement.attrs.stamp)
            : new Date() /* TODO: replace with entity time plugin */;

        const from &#x3D; parseJid(messageStanza.attrs.from);
        const room &#x3D; this.getRoomByJid(from.bare());
        if (!room) {
            // there are several reasons why we can receive a message for an unknown room:
            // - this is a message delivered via MAM/MUCSub but the room it was stored for
            //   - is gone (was destroyed)
            //   - user was banned from room
            //   - room wasn&#x27;t joined yet
            // - this is some kind of error on developer&#x27;s side
            this.logService.warn(&#x60;received stanza for unknown room: ${from.bare().toString()}&#x60;);
            return false;
        }

        const message: RoomMessage &#x3D; {
            body: messageStanza.getChildText(&#x27;body&#x27;).trim(),
            datetime,
            id: messageStanza.attrs.id,
            from,
            direction: from.equals(room.occupantJid) ? Direction.out : Direction.in,
            delayed: !!delayElement,
            fromArchive: archiveDelayElement !&#x3D; null,
        };

        const messageReceivedEvent &#x3D; new MessageReceivedEvent();
        for (const plugin of this.xmppChatAdapter.plugins) {
            plugin.afterReceiveMessage(message, messageStanza, messageReceivedEvent);
        }
        if (!messageReceivedEvent.discard) {
            room.addMessage(message);
        }

        if (!message.delayed) {
            this.message$.next(room);
        }

        return true;
    }

    private isRoomSubjectStanza(stanza: Stanza): boolean {
        return stanza.name &#x3D;&#x3D;&#x3D; &#x27;message&#x27;
            &amp;&amp; stanza.attrs.type &#x3D;&#x3D;&#x3D; &#x27;groupchat&#x27;
            &amp;&amp; stanza.getChild(&#x27;subject&#x27;) !&#x3D; null
            &amp;&amp; stanza.getChild(&#x27;body&#x27;) &#x3D;&#x3D; null;
    }

    private handleRoomSubjectStanza(stanza: Stanza, archiveDelayElement: Stanza): boolean {
        const roomJid &#x3D; parseJid(stanza.attrs.from).bare();
        const room &#x3D; this.getRoomByJid(roomJid);

        if (!room) {
            throw new Error(&#x60;unknown room trying to change room subject: roomJid&#x3D;${roomJid.toString()}&#x60;);
        }

        // The archive only stores non-empty subjects. The current value of the subject is sent directly after entering a room by the room,
        // not the archive.
        // If a subject was first set, then unset, we would first receive the empty subject on room entry and then overwrite it with the
        // previous non-empty value from archive. This is why we want to always ignore subjects from archive.
        // This actually looks like a bug in MAM, it seems that MAM interprets messages with just subject in them as if they were chat
        // messages and not room metadata. This would explain why empty subjects are not stored.
        if (archiveDelayElement) {
            return true;
        }

        room.subject &#x3D; stanza.getChild(&#x27;subject&#x27;).getText().trim();
        this.rooms$.next(this.rooms$.getValue());

        return true;
    }

    private handleRoomInvitationStanza(stanza: Stanza): boolean {
        const xEl &#x3D; stanza.getChild(&#x27;x&#x27;, mucUserNs);
        const invitationEl &#x3D; xEl.getChild(&#x27;invite&#x27;) ?? xEl.getChild(&#x27;decline&#x27;);

        this.onInvitationSubject.next({
            type: invitationEl.name as Invitation[&#x27;type&#x27;],
            roomJid: parseJid(stanza.attrs.from),
            roomPassword: xEl.getChild(&#x27;password&#x27;)?.getText(),
            from: parseJid(invitationEl.attrs.from),
            message: invitationEl.getChild(&#x27;reason&#x27;)?.getText(),
        });

        return true;
    }

    private async setAffiliation(occupantJid: JID, roomJid: JID, affiliation: Affiliation, reason?: string): Promise&lt;IqResponseStanza&gt; {
        const userJid &#x3D; await this.getUserJidByOccupantJid(occupantJid, roomJid);

        return await this.modifyAffiliationOrRole(roomJid, {userJid, affiliation, reason});
    }

    private async setRole(occupantNick: string, roomJid: JID, role: Role, reason?: string): Promise&lt;IqResponseStanza&gt; {
        return await this.modifyAffiliationOrRole(roomJid, {nick: occupantNick, role, reason});
    }

    private async getUserJidByOccupantJid(occupantJid: JID, roomJid: JID): Promise&lt;JID&gt; {
        const users &#x3D; await this.queryUserList(roomJid);
        return users.find(roomUser &#x3D;&gt; roomUser.userIdentifiers.find(
            ids &#x3D;&gt; ids.nick &#x3D;&#x3D;&#x3D; occupantJid.resource || ids.userJid.bare().equals(occupantJid.bare())),
        )?.userIdentifiers?.[0].userJid;
    }
}
</code></pre>
    </div>
</div>









                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'class';
            var COMPODOC_CURRENT_PAGE_URL = 'QueryOccupantListStanzaBuilder.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
